grammar org.xtext.com.Javadsl with org.eclipse.xtext.common.Terminals

generate javadsl "http://www.xtext.org/com/Javadsl"

Head:
	java+=CompilationUnit
;

CompilationUnit:
  {CompilationUnit} package=(PackageStatement)? imports+=ImportStatement* type_declarations+=TypeDeclaration*
;

PackageStatement:
    'package' ObjectName ';'
;

ImportStatement:
    'import' ImportStatement_ 
;

ImportStatement_:
    ObjectName ('.' '*')? ';' 
;

ObjectName:
	ID ('.' ID)*
;

TypeDeclaration:
    (class_declaration=ClassDeclaration | interface_declaration=InterfaceDeclaration) ';' 
;

ClassDeclaration:
	{ClassDeclaration} modifiers+=Modifier* 'class' ID ('extends' ObjectName)? ('implements' ObjectName ('.' ObjectName)*)?  
	'{' (field_declarations+=FieldDeclaration)* '}'
;

InterfaceDeclaration:
	{InterfaceDeclaration} (Modifier)* 'interface' ID ('extends' ObjectName ( '.' ObjectName)* )? 
	'{' (field_declarations+=FieldDeclaration)* '}'
;

FieldDeclaration:
    ( declaration=(MethodDeclaration 
      | ConstructorDeclaration 
      | VariableDeclaration ) ) 
      | StaticInitializer 
      | {FieldDeclaration} ';'
;

StaticInitializer: 
      "static" StatementBlock ;

MethodDeclaration: 
      (Modifier)* Type ID 
      '(' (ParameterList)? ')' ('[' ']')* 
      (statement_block=StatementBlock | ';') ;

ConstructorDeclaration: 
      (Modifier)* ID '(' (ParameterList)? ')' 
      statement_block=StatementBlock ;
      
ParameterList: 
      Parameter (',' parameters+=Parameter)* ;
      
Parameter: 
      Type ID ('[' ']')* ;
      
StatementBlock: '{' {StatementBlock} (statements+=Statement)* '}' ;
      
VariableDeclaration: 
      (Modifier)* type=Type? variable_declarator=VariableDeclarator 
      (',' variable_declarators+=VariableDeclarator)* ';' ;

VariableDeclarator: 
      {VariableDeclarator} ID ('[' ']')* ( '=' variable_initializer=VariableInitializer )? ;

VariableInitializer: 
      expr=Expression 
      | ('{' (variable_initializer=VariableInitializer 
      (',' variable_initializers+=VariableInitializer)* (',')? )? '}') ;

Type: 
	specifier=TypeSpecifier ('[' ']')*
;

Expression: 
	NumericExpression 
; 

NumericExpression: 
	('-' | '++' | '--') BitExpression
      
	| BitExpression (('++' | '--') | ({Numeric.left=current}('+' | '+=' | '-' | '-=' | '*' | '*=' | '/' | '/=' | '%' | '%=') right=BitExpression)*)
;

BitExpression:
	'~' LogicalExpression
    | LogicalExpression ({Bit.left=current}('>>=' | '<<' | '>>' | '>>>') right=LogicalExpression)* 
;

TestingExpression returns TestingExpression: 
      ArgsExpression
      ( {Testing.left=current}('>' | '<' | '>=' | '<=' | '==' | '!=') right=ArgsExpression )*
;

LogicalExpression returns LogicalExpression: 
    '!' right=TestingExpression
      | TestingExpression ({Logical.left=current}("&" | "&=" | '|' | '|=' | '^' | '^=' | "&&" | '||=' | '||') right=TestingExpression | {Logical.left=current}'?' right=TestingExpression {Logical.ternary=current}':' ternary_end=TestingExpression)* 
      | {LogicalExpression} "true" 
      | {LogicalExpression} "false"
;

ArgsExpression:
	CastingExpression ('(' arg_list+=Arglist? ')'| {Args.left=current}'.' right=CastingExpression | {Args.left=current}'[' right=CastingExpression ']' | {Args.left=current}',' right=CastingExpression | {Args.left=current}'instanceof' ObjectName )*
;

Arglist: arg=CastingExpression (',' args+=CastingExpression)* ;
      
CastingExpression: 
      CreatingExpression ({Casting.left=current}'(' types+=Type ')' right=CreatingExpression)*;
      
CreatingExpression: 
	ParenthesisExpression
      ("new" (
      	(ObjectName '(' (arg_list+=Arglist)? ')') | (type_specifiers+=TypeSpecifier ('[' parenthesis+=ParenthesisExpression ']')? ('[' ']')*)
      ))* ;

ParenthesisExpression:
	PrimaryExpression ('(' parenthesis+=PrimaryExpression ')')*
;

PrimaryExpression: 
	{PrimaryExpression} (value=LiteralExpression| "null" |  "super" |  "this" |  ID)
;

LiteralExpression: 
     literal_value=(IntegerLiteral | FloatLiteral | STRING | Character)      
;

TypeSpecifier: 
	name=("boolean"
	| "byte" 
	| "char" 
	| "short" 
	| "int" 
	| "float" 
	| "long" 
	| "double" 
	| ObjectName)
;

Modifier:
	"public" 
	| "private" 
	| "protected" 
	| "static" 
	| "final" 
	| "native" 
	| "synchronized" 
	| "abstract" 
	| "threadsafe" 
	| "transient" 
;

Character: 
	STRING ;

decimal_digits: 
	INT INT*
;

DoStatement: 
      "do" statement=Statement "while" '(' expression=Expression ')' ';' ;

exponent_part: 
	('0..9e');

IntegerLiteral:
	decimal_integer_literal |
	hex_integer_literal |
	octal_integer_literal
;

decimal_integer_literal: decimal_digits NUMBER_SUFFIX?;

hex_integer_literal: hexa_numeral NUMBER_SUFFIX?;

hexa_numeral:
	('0x'|'0X') HEXA | HEXA
;

octal_integer_literal: octal_numeral NUMBER_SUFFIX?;

octal_numeral:
	ZERO_TO_SEVEN*	
;

FloatLiteral: 
	decimal_digits '.'? decimal_digits? (exponent_part)? FLOAT_SUFFIX?
	| '.' decimal_digits (exponent_part)? FLOAT_SUFFIX? 	
;

ForStatement: 
	"for" '(' (variable_declaration=VariableDeclaration | (for_expression1=Expression ';') | ';') 
	for_expression2=Expression? ';' 
	for_expression3=Expression? ';' 
	')' statement=Statement ;

IfStatement: 
      "if" '(' expression=Expression ')' if_statement=Statement 
      ("else" else_statement=Statement)? ;	   

Statement: 
	variable_declaration=VariableDeclaration 
	| (statement_expression=Expression ';') 
	| (statement_block=StatementBlock) 
	| (if_statement=IfStatement) 
	| (do_statement=DoStatement) 
	| (while_statement=while_statement) 
	| (for_statement=ForStatement) 
	| (try_statement=TryStatement) 
	| (swith_statement=SwitchStatement) 
	| {Statement} ("synchronized" '(' sync_expression=Expression ')' sync_statement=Statement) 
	| {Statement} ("return" (return_expression=Expression)? ';') 
	| {Statement} ("throw" throw_expression=Expression ';') 
	| {Statement} (ID ':' named_statement=Statement) 
	| {Statement} ("break" (ID)? ';') 
	| {Statement} ("continue" (ID)? ';') 
	| {Statement} (';');

SwitchStatement: 
	"switch" '(' switch_expression=Expression ')' '{' 
	( ("case" case_expressions+=Expression ':') 
	| ("default" ':') 
	| statements+=Statement )*
	'}' ;

TryStatement: 
	"try" try_statement=Statement 
	("catch" '(' paramenters+=Parameter ')' catch_statements+=Statement)* 
	("finally" finally_statement=Statement)? ;

while_statement: 
	"while" '(' expression=Expression ')' statement=Statement ;

terminal HEXA:
	('0..9a..f')
;

terminal FLOAT_SUFFIX:
	('0..9f') | ('0..9d')
;

terminal NUMBER_SUFFIX:
	('0..9L') | ('0..9l')
;

terminal ZERO_TO_SEVEN:
	('0..7')
;