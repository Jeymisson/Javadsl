/*
 * generated by Xtext
 */
package org.xtext.com.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.com.javadsl.Arglist;
import org.xtext.com.javadsl.Args;
import org.xtext.com.javadsl.Bit;
import org.xtext.com.javadsl.Casting;
import org.xtext.com.javadsl.ClassDeclaration;
import org.xtext.com.javadsl.CompilationUnit;
import org.xtext.com.javadsl.ConstructorDeclaration;
import org.xtext.com.javadsl.DoStatement;
import org.xtext.com.javadsl.FieldDeclaration;
import org.xtext.com.javadsl.ForStatement;
import org.xtext.com.javadsl.Head;
import org.xtext.com.javadsl.IfStatement;
import org.xtext.com.javadsl.InterfaceDeclaration;
import org.xtext.com.javadsl.JavadslPackage;
import org.xtext.com.javadsl.LiteralExpression;
import org.xtext.com.javadsl.Logical;
import org.xtext.com.javadsl.LogicalExpression;
import org.xtext.com.javadsl.Numeric;
import org.xtext.com.javadsl.PrimaryExpression;
import org.xtext.com.javadsl.Statement;
import org.xtext.com.javadsl.StatementBlock;
import org.xtext.com.javadsl.SwitchStatement;
import org.xtext.com.javadsl.Testing;
import org.xtext.com.javadsl.TryStatement;
import org.xtext.com.javadsl.Type;
import org.xtext.com.javadsl.TypeDeclaration;
import org.xtext.com.javadsl.TypeSpecifier;
import org.xtext.com.javadsl.VariableDeclaration;
import org.xtext.com.javadsl.VariableDeclarator;
import org.xtext.com.javadsl.VariableInitializer;
import org.xtext.com.javadsl.while_statement;
import org.xtext.com.services.JavadslGrammarAccess;

@SuppressWarnings("all")
public class JavadslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private JavadslGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == JavadslPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case JavadslPackage.ARGLIST:
				sequence_Arglist(context, (Arglist) semanticObject); 
				return; 
			case JavadslPackage.ARGS:
				sequence_ArgsExpression(context, (Args) semanticObject); 
				return; 
			case JavadslPackage.BIT:
				sequence_BitExpression(context, (Bit) semanticObject); 
				return; 
			case JavadslPackage.CASTING:
				if(context == grammarAccess.getArgsExpressionRule() ||
				   context == grammarAccess.getArgsExpressionAccess().getArgsLeftAction_1_1_0() ||
				   context == grammarAccess.getArgsExpressionAccess().getArgsLeftAction_1_2_0() ||
				   context == grammarAccess.getArgsExpressionAccess().getArgsLeftAction_1_3_0() ||
				   context == grammarAccess.getArgsExpressionAccess().getArgsLeftAction_1_4_0() ||
				   context == grammarAccess.getBitExpressionRule() ||
				   context == grammarAccess.getBitExpressionAccess().getBitLeftAction_1_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getLogicalExpressionRule() ||
				   context == grammarAccess.getLogicalExpressionAccess().getLogicalLeftAction_1_1_0_0() ||
				   context == grammarAccess.getLogicalExpressionAccess().getLogicalLeftAction_1_1_1_0() ||
				   context == grammarAccess.getNumericExpressionRule() ||
				   context == grammarAccess.getNumericExpressionAccess().getNumericLeftAction_1_1_1_0() ||
				   context == grammarAccess.getTestingExpressionRule() ||
				   context == grammarAccess.getTestingExpressionAccess().getTestingLeftAction_1_0()) {
					sequence_ArgsExpression_CastingExpression(context, (Casting) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getCastingExpressionRule() ||
				   context == grammarAccess.getCastingExpressionAccess().getCastingLeftAction_1_0()) {
					sequence_CastingExpression(context, (Casting) semanticObject); 
					return; 
				}
				else break;
			case JavadslPackage.CLASS_DECLARATION:
				sequence_ClassDeclaration(context, (ClassDeclaration) semanticObject); 
				return; 
			case JavadslPackage.COMPILATION_UNIT:
				sequence_CompilationUnit(context, (CompilationUnit) semanticObject); 
				return; 
			case JavadslPackage.CONSTRUCTOR_DECLARATION:
				sequence_ConstructorDeclaration(context, (ConstructorDeclaration) semanticObject); 
				return; 
			case JavadslPackage.DO_STATEMENT:
				sequence_DoStatement(context, (DoStatement) semanticObject); 
				return; 
			case JavadslPackage.FIELD_DECLARATION:
				sequence_FieldDeclaration(context, (FieldDeclaration) semanticObject); 
				return; 
			case JavadslPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case JavadslPackage.HEAD:
				sequence_Head(context, (Head) semanticObject); 
				return; 
			case JavadslPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case JavadslPackage.INTERFACE_DECLARATION:
				sequence_InterfaceDeclaration(context, (InterfaceDeclaration) semanticObject); 
				return; 
			case JavadslPackage.LITERAL_EXPRESSION:
				sequence_LiteralExpression(context, (LiteralExpression) semanticObject); 
				return; 
			case JavadslPackage.LOGICAL:
				if(context == grammarAccess.getBitExpressionRule() ||
				   context == grammarAccess.getBitExpressionAccess().getBitLeftAction_1_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getLogicalExpressionRule() ||
				   context == grammarAccess.getLogicalExpressionAccess().getLogicalLeftAction_1_1_0_0() ||
				   context == grammarAccess.getLogicalExpressionAccess().getLogicalLeftAction_1_1_1_0() ||
				   context == grammarAccess.getNumericExpressionRule() ||
				   context == grammarAccess.getNumericExpressionAccess().getNumericLeftAction_1_1_1_0()) {
					sequence_LogicalExpression(context, (Logical) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getLogicalExpressionAccess().getLogicalTernaryAction_1_1_1_3()) {
					sequence_LogicalExpression_Logical_1_1_1_3(context, (Logical) semanticObject); 
					return; 
				}
				else break;
			case JavadslPackage.LOGICAL_EXPRESSION:
				sequence_LogicalExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case JavadslPackage.NUMERIC:
				sequence_NumericExpression(context, (Numeric) semanticObject); 
				return; 
			case JavadslPackage.PRIMARY_EXPRESSION:
				if(context == grammarAccess.getArgsExpressionRule() ||
				   context == grammarAccess.getArgsExpressionAccess().getArgsLeftAction_1_1_0() ||
				   context == grammarAccess.getArgsExpressionAccess().getArgsLeftAction_1_2_0() ||
				   context == grammarAccess.getArgsExpressionAccess().getArgsLeftAction_1_3_0() ||
				   context == grammarAccess.getArgsExpressionAccess().getArgsLeftAction_1_4_0() ||
				   context == grammarAccess.getBitExpressionRule() ||
				   context == grammarAccess.getBitExpressionAccess().getBitLeftAction_1_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getLogicalExpressionRule() ||
				   context == grammarAccess.getLogicalExpressionAccess().getLogicalLeftAction_1_1_0_0() ||
				   context == grammarAccess.getLogicalExpressionAccess().getLogicalLeftAction_1_1_1_0() ||
				   context == grammarAccess.getNumericExpressionRule() ||
				   context == grammarAccess.getNumericExpressionAccess().getNumericLeftAction_1_1_1_0() ||
				   context == grammarAccess.getTestingExpressionRule() ||
				   context == grammarAccess.getTestingExpressionAccess().getTestingLeftAction_1_0()) {
					sequence_ArgsExpression_CreatingExpression_ParenthesisExpression_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getCastingExpressionRule() ||
				   context == grammarAccess.getCastingExpressionAccess().getCastingLeftAction_1_0() ||
				   context == grammarAccess.getCreatingExpressionRule()) {
					sequence_CreatingExpression_ParenthesisExpression_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getParenthesisExpressionRule()) {
					sequence_ParenthesisExpression_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPrimaryExpressionRule()) {
					sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
					return; 
				}
				else break;
			case JavadslPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case JavadslPackage.STATEMENT_BLOCK:
				sequence_StatementBlock(context, (StatementBlock) semanticObject); 
				return; 
			case JavadslPackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case JavadslPackage.TESTING:
				sequence_TestingExpression(context, (Testing) semanticObject); 
				return; 
			case JavadslPackage.TRY_STATEMENT:
				sequence_TryStatement(context, (TryStatement) semanticObject); 
				return; 
			case JavadslPackage.TYPE:
				if(context == grammarAccess.getConstructorDeclarationRule()) {
					sequence_ConstructorDeclaration_ParameterList_Type(context, (Type) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getMethodDeclarationRule()) {
					sequence_MethodDeclaration_Type(context, (Type) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getParameterListRule()) {
					sequence_ParameterList_Type(context, (Type) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getParameterRule() ||
				   context == grammarAccess.getTypeRule()) {
					sequence_Type(context, (Type) semanticObject); 
					return; 
				}
				else break;
			case JavadslPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case JavadslPackage.TYPE_SPECIFIER:
				sequence_TypeSpecifier(context, (TypeSpecifier) semanticObject); 
				return; 
			case JavadslPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case JavadslPackage.VARIABLE_DECLARATOR:
				sequence_VariableDeclarator(context, (VariableDeclarator) semanticObject); 
				return; 
			case JavadslPackage.VARIABLE_INITIALIZER:
				sequence_VariableInitializer(context, (VariableInitializer) semanticObject); 
				return; 
			case JavadslPackage.WHILE_STATEMENT:
				sequence_while_statement(context, (while_statement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (arg=CastingExpression args+=CastingExpression*)
	 */
	protected void sequence_Arglist(EObject context, Arglist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (left=ArgsExpression_Args_1_1_0 right=CastingExpression arg_list+=Arglist?) | 
	 *         (left=ArgsExpression_Args_1_2_0 right=CastingExpression arg_list+=Arglist?) | 
	 *         (left=ArgsExpression_Args_1_3_0 right=CastingExpression arg_list+=Arglist?) | 
	 *         (left=ArgsExpression_Args_1_4_0 arg_list+=Arglist?) | 
	 *         left=ArgsExpression_Args_1_4_0
	 *     )
	 */
	protected void sequence_ArgsExpression(EObject context, Args semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=CastingExpression_Casting_1_0 types+=Type right=CreatingExpression arg_list+=Arglist?)
	 */
	protected void sequence_ArgsExpression_CastingExpression(EObject context, Casting semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         value=LiteralExpression? 
	 *         parenthesis+=PrimaryExpression* 
	 *         (arg_list+=Arglist? | (type_specifiers+=TypeSpecifier parenthesis+=ParenthesisExpression?))* 
	 *         arg_list+=Arglist?
	 *     )
	 */
	protected void sequence_ArgsExpression_CreatingExpression_ParenthesisExpression_PrimaryExpression(EObject context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=BitExpression_Bit_1_1_0 right=LogicalExpression)
	 */
	protected void sequence_BitExpression(EObject context, Bit semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.NUMERIC_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.NUMERIC_EXPRESSION__RIGHT));
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.BIT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.BIT__LEFT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBitExpressionAccess().getBitLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitExpressionAccess().getRightLogicalExpressionParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=CastingExpression_Casting_1_0 types+=Type right=CreatingExpression)
	 */
	protected void sequence_CastingExpression(EObject context, Casting semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (modifiers+=Modifier* field_declarations+=FieldDeclaration*)
	 */
	protected void sequence_ClassDeclaration(EObject context, ClassDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (package=PackageStatement? imports+=ImportStatement* type_declarations+=TypeDeclaration*)
	 */
	protected void sequence_CompilationUnit(EObject context, CompilationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     statement_block=StatementBlock
	 */
	protected void sequence_ConstructorDeclaration(EObject context, ConstructorDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.CONSTRUCTOR_DECLARATION__STATEMENT_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.CONSTRUCTOR_DECLARATION__STATEMENT_BLOCK));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConstructorDeclarationAccess().getStatement_blockStatementBlockParserRuleCall_5_0(), semanticObject.getStatement_block());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (specifier=TypeSpecifier parameters+=Parameter* statement_block=StatementBlock)
	 */
	protected void sequence_ConstructorDeclaration_ParameterList_Type(EObject context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         value=LiteralExpression? 
	 *         parenthesis+=PrimaryExpression* 
	 *         (arg_list+=Arglist? | (type_specifiers+=TypeSpecifier parenthesis+=ParenthesisExpression?))*
	 *     )
	 */
	protected void sequence_CreatingExpression_ParenthesisExpression_PrimaryExpression(EObject context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (statement=Statement expression=Expression)
	 */
	protected void sequence_DoStatement(EObject context, DoStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.DO_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.DO_STATEMENT__STATEMENT));
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.DO_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.DO_STATEMENT__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDoStatementAccess().getStatementStatementParserRuleCall_1_0(), semanticObject.getStatement());
		feeder.accept(grammarAccess.getDoStatementAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {FieldDeclaration}
	 */
	protected void sequence_FieldDeclaration(EObject context, FieldDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (variable_declaration=VariableDeclaration | for_expression1=Expression)? 
	 *         for_expression2=Expression? 
	 *         for_expression3=Expression? 
	 *         statement=Statement
	 *     )
	 */
	protected void sequence_ForStatement(EObject context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     java+=CompilationUnit
	 */
	protected void sequence_Head(EObject context, Head semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=Expression if_statement=Statement else_statement=Statement?)
	 */
	protected void sequence_IfStatement(EObject context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (field_declarations+=FieldDeclaration*)
	 */
	protected void sequence_InterfaceDeclaration(EObject context, InterfaceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (literal_value=IntegerLiteral | literal_value=FloatLiteral | literal_value=STRING | literal_value=Character)
	 */
	protected void sequence_LiteralExpression(EObject context, LiteralExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((left=LogicalExpression_Logical_1_1_0_0 right=TestingExpression) | (ternary=LogicalExpression_Logical_1_1_1_3 ternary_end=TestingExpression))
	 */
	protected void sequence_LogicalExpression(EObject context, Logical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     right=TestingExpression
	 */
	protected void sequence_LogicalExpression(EObject context, LogicalExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.NUMERIC_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.NUMERIC_EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getRightTestingExpressionParserRuleCall_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=LogicalExpression_Logical_1_1_1_0 right=TestingExpression)
	 */
	protected void sequence_LogicalExpression_Logical_1_1_1_3(EObject context, Logical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (specifier=TypeSpecifier statement_block=StatementBlock?)
	 */
	protected void sequence_MethodDeclaration_Type(EObject context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=NumericExpression_Numeric_1_1_1_0 right=BitExpression)
	 */
	protected void sequence_NumericExpression(EObject context, Numeric semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.NUMERIC_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.NUMERIC_EXPRESSION__RIGHT));
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.NUMERIC__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.NUMERIC__LEFT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNumericExpressionAccess().getNumericLeftAction_1_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getNumericExpressionAccess().getRightBitExpressionParserRuleCall_1_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (specifier=TypeSpecifier parameters+=Parameter*)
	 */
	protected void sequence_ParameterList_Type(EObject context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=LiteralExpression? parenthesis+=PrimaryExpression*)
	 */
	protected void sequence_ParenthesisExpression_PrimaryExpression(EObject context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=LiteralExpression?)
	 */
	protected void sequence_PrimaryExpression(EObject context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (statements+=Statement*)
	 */
	protected void sequence_StatementBlock(EObject context, StatementBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((sync_expression=Expression sync_statement=Statement) | (return_expression=Expression?) | throw_expression=Expression | named_statement=Statement)
	 */
	protected void sequence_Statement(EObject context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (switch_expression=Expression (case_expressions+=Expression | statements+=Statement)*)
	 */
	protected void sequence_SwitchStatement(EObject context, SwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=TestingExpression_Testing_1_0 right=ArgsExpression)
	 */
	protected void sequence_TestingExpression(EObject context, Testing semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.NUMERIC_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.NUMERIC_EXPRESSION__RIGHT));
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.TESTING__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.TESTING__LEFT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTestingExpressionAccess().getTestingLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTestingExpressionAccess().getRightArgsExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (try_statement=Statement (paramenters+=Parameter catch_statements+=Statement)* finally_statement=Statement?)
	 */
	protected void sequence_TryStatement(EObject context, TryStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (class_declaration=ClassDeclaration | interface_declaration=InterfaceDeclaration)
	 */
	protected void sequence_TypeDeclaration(EObject context, TypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='boolean' | 
	 *         name='byte' | 
	 *         name='char' | 
	 *         name='short' | 
	 *         name='int' | 
	 *         name='float' | 
	 *         name='long' | 
	 *         name='double' | 
	 *         name=ObjectName
	 *     )
	 */
	protected void sequence_TypeSpecifier(EObject context, TypeSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     specifier=TypeSpecifier
	 */
	protected void sequence_Type(EObject context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type? variable_declarator=VariableDeclarator variable_declarators+=VariableDeclarator*)
	 */
	protected void sequence_VariableDeclaration(EObject context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (variable_initializer=VariableInitializer?)
	 */
	protected void sequence_VariableDeclarator(EObject context, VariableDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr=Expression | (variable_initializer=VariableInitializer variable_initializers+=VariableInitializer*)?)
	 */
	protected void sequence_VariableInitializer(EObject context, VariableInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=Expression statement=Statement)
	 */
	protected void sequence_while_statement(EObject context, while_statement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.WHILE_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.WHILE_STATEMENT__EXPRESSION));
			if(transientValues.isValueTransient(semanticObject, JavadslPackage.Literals.WHILE_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JavadslPackage.Literals.WHILE_STATEMENT__STATEMENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWhile_statementAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getWhile_statementAccess().getStatementStatementParserRuleCall_4_0(), semanticObject.getStatement());
		feeder.finish();
	}
}
