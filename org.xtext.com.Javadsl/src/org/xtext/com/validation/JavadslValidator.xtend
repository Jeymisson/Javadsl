/*
 * generated by Xtext
 */
package org.xtext.com.validation

import org.eclipse.xtext.validation.Check
import org.xtext.com.javadsl.BooleanType
import org.xtext.com.javadsl.ClassDeclaration
import org.xtext.com.javadsl.IfStatement
import org.xtext.com.javadsl.JavadslPackage
import org.xtext.com.javadsl.LogicalExpression
import org.xtext.com.javadsl.MethodDeclaration
import org.xtext.com.javadsl.ObjectType
import org.xtext.com.javadsl.ReturnStatement
import org.xtext.com.javadsl.TestingExpression
import org.xtext.com.javadsl.VariableDeclaration
import org.xtext.com.javadsl.VoidType
import java.util.Set
import java.util.HashSet
import java.util.LinkedList
import org.xtext.com.javadsl.Parameter

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class JavadslValidator extends AbstractJavadslValidator {
	
	var Iterable<MethodDeclaration> methods;
	
	@Check
	def checkType(VariableDeclaration v){
		if(!v.type.specifier.class.equals(
			v.variable_declarator.variable_initializer.expr.literal.class
		)){
			error("Invalid type " + v.type.specifier.name + " required", JavadslPackage.Literals.VARIABLE_DECLARATION__TYPE)
			return
		}
	}
	
	@Check
	def checkType(IfStatement statement){
		if(!(statement.expression instanceof LogicalExpression) &&
			!(statement.expression instanceof TestingExpression) &&
			!(statement.expression.literal instanceof BooleanType)
		){
			error("It's not boolean", JavadslPackage.Literals.IF_STATEMENT__EXPRESSION)
			return
		}
	}
	
	@Check
	def mapClasses(ClassDeclaration c){
		val fields = c.field_declarations.filter[it.declaration instanceof MethodDeclaration]
		methods = fields.map[it.declaration as MethodDeclaration]
		println("methods: " + methods + " length: " + methods.length)
	}
	
	@Check
	def checkMethod(MethodDeclaration m){
		val return_statements = m.body.statements.filter(typeof(ReturnStatement))
		val same_name = methods.filter[it.method_id.equals(m.method_id) && !it.identityEquals(m) && it.list.parameters.length == m.list.parameters.length];
		
		println("m: " + m + " m.list: " + m.list + " m.list.parameters: " + m.list.parameters)
		println("same-name: " + same_name + " length: " + same_name.length)
		
		checkParameters(same_name, m);
		
		if(!(m.type.specifier instanceof VoidType) && return_statements.isEmpty){
			error("Method should return "+ m.type.specifier.name, JavadslPackage.Literals.METHOD_DECLARATION__TYPE)
			return
		}
		for(st: return_statements){
			if((m.type.specifier instanceof ObjectType) && !st.return_expression.literal.equals(m.type.specifier)){
				error("Method should return "+ m.type.specifier.name + " type", JavadslPackage.Literals.METHOD_DECLARATION__TYPE)
				return
			}else if(m.type.specifier instanceof VoidType){
				error("Void methods can't return a value", JavadslPackage.Literals.METHOD_DECLARATION__TYPE)
				return
			}else if(!m.type.specifier.class.equals(st.return_expression.literal.class)){
				error("Method should return " + m.type.specifier.name, JavadslPackage.Literals.METHOD_DECLARATION__TYPE)
				return
			}
		}
	}
	
	def checkParameters(Iterable<MethodDeclaration> methods, MethodDeclaration m) {
		var pm = new LinkedList<Parameter>(m.list.parameters)
		pm.add(m.list.parameter)
		for(mi:methods){
			var pn = new LinkedList<Parameter>(mi.list.parameters)
			pn.add(mi.list.parameter)
			var equal = true
			for(var i=0; i<pm.length; i++){
				if(!pm.get(i).type.class.equals(pn.get(i).type.class)){
					equal = false;
				}
			}
			println("pn: " + pn + " pm: " +  pm + " equal: " + equal)
			if(equal){
				error("Duplicate method " + m.method_id, JavadslPackage.Literals.METHOD_DECLARATION__METHOD_ID)
			}
		}
	}
}